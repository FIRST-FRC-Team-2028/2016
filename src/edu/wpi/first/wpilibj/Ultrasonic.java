/*----------------------------------------------------------------------------*/
/* Open Source Software - may be modified and shared by FRC teams. The code   */
/* must be accompanied by the FIRST BSD license file in the root directory of */
/* the project.                                                               */
/*----------------------------------------------------------------------------*/
package edu.wpi.first.wpilibj;

import com.modeliosoft.modelio.javadesigner.annotations.objid;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.communication.FRCNetworkCommunicationsLibrary.tResourceType;
import edu.wpi.first.wpilibj.communication.UsageReporting;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.livewindow.LiveWindowSendable;
import edu.wpi.first.wpilibj.tables.ITable;

/**
 * Ultrasonic rangefinder class. The Ultrasonic rangefinder measures absolute
 * distance based on the round-trip time of a ping generated by the controller.
 * These sensors use two transducers, a speaker and a microphone both tuned to
 * the ultrasonic range. A common ultrasonic sensor, the Daventech SRF04
 * requires a short pulse to be generated on a digital channel. This causes the
 * chirp to be emmitted. A second line becomes high as the ping is transmitted
 * and goes low when the echo is received. The time that the line is high
 * determines the round trip distance (time of flight).
 */
@objid ("9a9f8fb9-dd40-4755-acaa-3cbb02a92f5c")
public class Ultrasonic extends SensorBase implements PIDSource, LiveWindowSendable {
    @objid ("a6efd698-2d3c-4d44-8810-5ef85e39e4c6")
    private static final double kPingTime = 10 * 1e-6; // /< Time (sec) for the

// ping trigger pulse.
    @objid ("9ddf278d-1b1a-47a2-91f1-ee58f72162d3")
    private static final int kPriority = 90; // /< Priority that the ultrasonic

// round robin task runs.
    @objid ("cddafc4e-afe3-4391-b5b4-ebbd9d07f4f7")
    private static final double kMaxUltrasonicTime = 0.1; // /< Max time (ms)

// between readings.
    @objid ("6a0fd027-086b-4b08-88c8-c9af0931aae8")
    private static final double kSpeedOfSoundInchesPerSec = 1130.0 * 12.0;

// sensor list
    @objid ("77187e79-c0b3-447b-bbea-3940c2042599")
    private static boolean m_automaticEnabled = false; // automatic round robin

    @objid ("fc3e1a20-524f-4e56-86bb-02180af7bd73")
    private boolean m_allocatedChannels;

    @objid ("dbaa5b34-dc1b-48da-a57c-3a71cfc64b9d")
    private boolean m_enabled = false;

    @objid ("6465ae5c-8532-4eb5-bf88-888b7b087a19")
    private static Thread m_task = null; // task doing the round-robin automatic

    @objid ("7e7c3170-6079-42d0-b5e7-56f7e86fe710")
    private static int m_instances = 0;

    @objid ("bcdfc0a3-d67a-445e-bffa-da9e756848e3")
    private ITable m_table;

    @objid ("686af094-337d-4599-a773-d800cf301b76")
    private static Ultrasonic m_firstSensor = null; // head of the ultrasonic

// mode
    @objid ("2cb732e4-52d3-4d43-adaf-bf6c6de0351e")
    private DigitalInput m_echoChannel = null;

    @objid ("706edcf6-d1ed-4c35-badf-cfd819166406")
    private DigitalOutput m_pingChannel = null;

    @objid ("7023c5a8-95b0-4355-8d05-79f8efb9dcbe")
    private Counter m_counter = null;

    @objid ("6aefd4e0-6bd2-46a5-b19a-13151d94cfe2")
    private Ultrasonic m_nextSensor = null;

// sensing
    @objid ("3abc44bb-c1f3-462f-9fe1-4be695b1440b")
    private Unit m_units;

    /**
     * Initialize the Ultrasonic Sensor. This is the common code that
     * initializes the ultrasonic sensor given that there are two digital I/O
     * channels allocated. If the system was running in automatic mode (round
     * robin) when the new sensor is added, it is stopped, the sensor is added,
     * then automatic mode is restored.
     */
    @objid ("6f5310f2-20b1-4dbd-9a38-42270f2a022e")
    private synchronized void initialize() {
        if (m_task == null) {
            m_task = new UltrasonicChecker();
        }
        boolean originalMode = m_automaticEnabled;
        setAutomaticMode(false); // kill task when adding a new sensor
        m_nextSensor = m_firstSensor;
        m_firstSensor = this;
        
        m_counter = new Counter(m_echoChannel); // set up counter for this
                                                // sensor
        m_counter.setMaxPeriod(1.0);
        m_counter.setSemiPeriodMode(true);
        m_counter.reset();
        m_enabled = true; // make it available for round robin scheduling
        setAutomaticMode(originalMode);
        
        m_instances++;
        UsageReporting.report(tResourceType.kResourceType_Ultrasonic,
                m_instances);
        LiveWindow.addSensor("Ultrasonic", m_echoChannel.getChannel(), this);
    }

    /**
     * Create an instance of the Ultrasonic Sensor.
     * This is designed to supchannel the Daventech SRF04 and Vex ultrasonic
     * sensors.
     * @param pingChannel The digital output channel that sends the pulse to initiate
     * the sensor sending the ping.
     * @param echoChannel The digital input channel that receives the echo. The length
     * of time that the echo is high represents the round trip time
     * of the ping, and the distance.
     * @param units The units returned in either kInches or kMilliMeters
     */
    @objid ("d80402a9-4941-4302-bdda-40f090dd962b")
    public Ultrasonic(final int pingChannel, final int echoChannel, Unit units) {
        m_pingChannel = new DigitalOutput(pingChannel);
        m_echoChannel = new DigitalInput(echoChannel);
        m_allocatedChannels = true;
        m_units = units;
        initialize();
    }

    /**
     * Create an instance of the Ultrasonic Sensor.
     * This is designed to supchannel the Daventech SRF04 and Vex ultrasonic
     * sensors. Default unit is inches.
     * @param pingChannel The digital output channel that sends the pulse to initiate
     * the sensor sending the ping.
     * @param echoChannel The digital input channel that receives the echo. The length
     * of time that the echo is high represents the round trip time
     * of the ping, and the distance.
     */
    @objid ("be61e238-e722-400e-94c2-850ba7966c0e")
    public Ultrasonic(final int pingChannel, final int echoChannel) {
        this(pingChannel, echoChannel, Unit.kInches);
    }

    /**
     * Create an instance of an Ultrasonic Sensor from a DigitalInput for the
     * echo channel and a DigitalOutput for the ping channel.
     * @param pingChannel The digital output object that starts the sensor doing a ping.
     * Requires a 10uS pulse to start.
     * @param echoChannel The digital input object that times the return pulse to
     * determine the range.
     * @param units The units returned in either kInches or kMilliMeters
     */
    @objid ("883ea408-c108-4ac7-896b-61912f11a3ae")
    public Ultrasonic(DigitalOutput pingChannel, DigitalInput echoChannel, Unit units) {
        if (pingChannel == null || echoChannel == null) {
            throw new NullPointerException("Null Channel Provided");
        }
        m_allocatedChannels = false;
        m_pingChannel = pingChannel;
        m_echoChannel = echoChannel;
        m_units = units;
        initialize();
    }

    /**
     * Create an instance of an Ultrasonic Sensor from a DigitalInput for the
     * echo channel and a DigitalOutput for the ping channel. Default unit is
     * inches.
     * @param pingChannel The digital output object that starts the sensor doing a ping.
     * Requires a 10uS pulse to start.
     * @param echoChannel The digital input object that times the return pulse to
     * determine the range.
     */
    @objid ("09313ee7-0bcb-41b8-8eb6-4896e81636a4")
    public Ultrasonic(DigitalOutput pingChannel, DigitalInput echoChannel) {
        this(pingChannel, echoChannel, Unit.kInches);
    }

    /**
     * Destructor for the ultrasonic sensor. Delete the instance of the
     * ultrasonic sensor by freeing the allocated digital channels. If the
     * system was in automatic mode (round robin), then it is stopped, then
     * started again after this sensor is removed (provided this wasn't the last
     * sensor).
     */
    @objid ("7d062be3-215e-4ccb-a1e7-3564eaff0851")
    public synchronized void free() {
        boolean wasAutomaticMode = m_automaticEnabled;
        setAutomaticMode(false);
        if (m_allocatedChannels) {
            if (m_pingChannel != null) {
                m_pingChannel.free();
            }
            if (m_echoChannel != null) {
                m_echoChannel.free();
            }
        }
        
        if (m_counter != null) {
            m_counter.free();
            m_counter = null;
        }
        
        m_pingChannel = null;
        m_echoChannel = null;
        
        if (this == m_firstSensor) {
            m_firstSensor = m_nextSensor;
            if (m_firstSensor == null) {
                setAutomaticMode(false);
            }
        } else {
            for (Ultrasonic s = m_firstSensor; s != null; s = s.m_nextSensor) {
                if (this == s.m_nextSensor) {
                    s.m_nextSensor = s.m_nextSensor.m_nextSensor;
                    break;
                }
            }
        }
        if (m_firstSensor != null && wasAutomaticMode) {
            setAutomaticMode(true);
        }
    }

    /**
     * Turn Automatic mode on/off. When in Automatic mode, all sensors will fire
     * in round robin, waiting a set time between each sensor.
     * @param enabling Set to true if round robin scheduling should start for all the
     * ultrasonic sensors. This scheduling method assures that the
     * sensors are non-interfering because no two sensors fire at the
     * same time. If another scheduling algorithm is preffered, it
     * can be implemented by pinging the sensors manually and waiting
     * for the results to come back.
     */
    @objid ("a46bcd8c-5713-44e7-bd57-e4779c7f5d30")
    public void setAutomaticMode(boolean enabling) {
        if (enabling == m_automaticEnabled) {
            return; // ignore the case of no change
        }
        m_automaticEnabled = enabling;
        
        if (enabling) {
            // enabling automatic mode.
            // Clear all the counters so no data is valid
            for (Ultrasonic u = m_firstSensor; u != null; u = u.m_nextSensor) {
                u.m_counter.reset();
            }
            // Start round robin task
            m_task.start();
        } else {
            // disabling automatic mode. Wait for background task to stop
            // running.
            while (m_task.isAlive()) {
                Timer.delay(.15); // just a little longer than the ping time for
                                    // round-robin to stop
            }
            // clear all the counters (data now invalid) since automatic mode is
            // stopped
            for (Ultrasonic u = m_firstSensor; u != null; u = u.m_nextSensor) {
                u.m_counter.reset();
            }
        }
    }

    /**
     * Single ping to ultrasonic sensor. Send out a single ping to the
     * ultrasonic sensor. This only works if automatic (round robin) mode is
     * disabled. A single ping is sent out, and the counter should count the
     * semi-period when it comes in. The counter is reset to make the current
     * value invalid.
     */
    @objid ("62e185e4-3d1b-4d3f-ad7f-955f04e50b77")
    public void ping() {
        setAutomaticMode(false); // turn off automatic round robin if pinging
                                    // single sensor
        m_counter.reset(); // reset the counter to zero (invalid data now)
        m_pingChannel.pulse(m_pingChannel.m_channel, (float) kPingTime); // do
                                                                            // the
                                                                            // ping
                                                                            // to
                                                                            // start
                                                                            // getting
                                                                            // a
                                                                            // single
                                                                            // range
    }

    /**
     * Check if there is a valid range measurement. The ranges are accumulated
     * in a counter that will increment on each edge of the echo (return)
     * signal. If the count is not at least 2, then the range has not yet been
     * measured, and is invalid.
     * @return true if the range is valid
     */
    @objid ("e171fae2-e2b9-4917-98ec-0e24b477b805")
    public boolean isRangeValid() {
        return m_counter.get() > 1;
    }

    /**
     * Get the range in inches from the ultrasonic sensor.
     * @return double Range in inches of the target returned from the ultrasonic
     * sensor. If there is no valid value yet, i.e. at least one
     * measurement hasn't completed, then return 0.
     */
    @objid ("e78e653f-2270-4049-b5ea-212c22935b56")
    public double getRangeInches() {
        if (isRangeValid()) {
            return m_counter.getPeriod() * kSpeedOfSoundInchesPerSec / 2.0;
        } else {
            return 0;
        }
    }

    /**
     * Get the range in millimeters from the ultrasonic sensor.
     * @return double Range in millimeters of the target returned by the
     * ultrasonic sensor. If there is no valid value yet, i.e. at least
     * one measurement hasn't complted, then return 0.
     */
    @objid ("cf2e81a8-b67f-4ad0-be80-27dfa01ea0f9")
    public double getRangeMM() {
        return getRangeInches() * 25.4;
    }

    /**
     * Get the result to use in PIDController
     * @return the result to use in PIDController
     */
    @objid ("6977902e-8bc1-40d5-8b2c-0c53b24cbe60")
    public double pidGet() {
        switch (m_units.value) {
        case Unit.kInches_val:
            return getRangeInches();
        case Unit.kMillimeters_val:
            return getRangeMM();
        default:
            return 0.0;
        }
    }

    /**
     * Set the current DistanceUnit that should be used for the PIDSource base
     * object.
     * @param units The DistanceUnit that should be used.
     */
    @objid ("0d4ca82f-f405-4cc8-927d-1acdf0a45789")
    public void setDistanceUnits(Unit units) {
        m_units = units;
    }

    /**
     * Get the current DistanceUnit that is used for the PIDSource base object.
     * @return The type of DistanceUnit that is being used.
     */
    @objid ("62355a37-52a0-4ecd-b543-c6830925be08")
    public Unit getDistanceUnits() {
        return m_units;
    }

    /**
     * Is the ultrasonic enabled
     * @return true if the ultrasonic is enabled
     */
    @objid ("d6441bb8-85f6-4e9b-aced-2cf7940dbce1")
    public boolean isEnabled() {
        return m_enabled;
    }

    /**
     * Set if the ultrasonic is enabled
     * @param enable set to true to enable the ultrasonic
     */
    @objid ("50a03a26-44f5-4959-ac46-25fa47183aa1")
    public void setEnabled(boolean enable) {
        m_enabled = enable;
    }

/*
     * Live Window code, only does anything if live window is activated.
     */
    @objid ("9eaa3e36-ec79-4a97-a906-bc05c0e1199d")
    public String getSmartDashboardType() {
        return "Ultrasonic";
    }

    /**
     * {@inheritDoc}
     */
    @objid ("44be7b8c-e8eb-469c-957e-0d28e6a9b571")
    public void initTable(ITable subtable) {
        m_table = subtable;
        updateTable();
    }

    /**
     * {@inheritDoc}
     */
    @objid ("2a5bdf05-f5ad-4d16-b19f-4abb64245915")
    public ITable getTable() {
        return m_table;
    }

    /**
     * {@inheritDoc}
     */
    @objid ("4c3c49b6-1e7a-43ac-bd84-d5d28088c3b1")
    public void updateTable() {
        if (m_table != null) {
            m_table.putNumber("Value", getRangeInches());
        }
    }

    /**
     * {@inheritDoc}
     */
    @objid ("8ebe11db-816b-400c-b3d2-f68804c56aad")
    public void startLiveWindowMode() {
    }

    /**
     * {@inheritDoc}
     */
    @objid ("3f40cba5-7381-4d1c-bb61-ccd4ac8ffe72")
    public void stopLiveWindowMode() {
    }

    /**
     * The units to return when PIDGet is called
     */
    @objid ("5709b0ed-d4ca-4b48-b3ff-e58ed4572a9c")
    public static class Unit {
        /**
         * The integer value representing this enumeration
         */
        @objid ("9e2a0a33-75d9-477b-8e9d-0d2727e54258")
        public final int value;

        @objid ("576e116b-cece-44ea-a608-aebccc4c7667")
         static final int kInches_val = 0;

        @objid ("01c68e9f-7f21-4786-af67-1347d01cd3d1")
         static final int kMillimeters_val = 1;

        /**
         * Use inches for PIDGet
         */
        @objid ("f3a2663e-287e-48e2-8b93-4921f94dd54d")
        public static final Unit kInches = new Unit(kInches_val);

        /**
         * Use millimeters for PIDGet
         */
        @objid ("6192d5d2-0929-46aa-a8b7-54956b574206")
        public static final Unit kMillimeter = new Unit(kMillimeters_val);

        @objid ("9eebb474-e38e-4938-b07c-db58ce9efed9")
        private Unit(int value) {
            this.value = value;
        }

    }

    /**
     * Background task that goes through the list of ultrasonic sensors and
     * pings each one in turn. The counter is configured to read the timing of
     * the returned echo pulse.
     * 
     * DANGER WILL ROBINSON, DANGER WILL ROBINSON: This code runs as a task and
     * assumes that none of the ultrasonic sensors will change while it's
     * running. If one does, then this will certainly break. Make sure to
     * disable automatic mode before changing anything with the sensors!!
     */
    @objid ("353e48f8-621f-485a-aa5f-00fa8a5627c0")
    private class UltrasonicChecker extends Thread {
        @objid ("4864847e-8334-4803-88da-3f45f54178ab")
        public synchronized void run() {
            Ultrasonic u = null;
            while (m_automaticEnabled) {
                if (u == null) {
                    u = m_firstSensor;
                }
                if (u == null) {
                    return;
                }
                if (u.isEnabled()) {
                    u.m_pingChannel.pulse(m_pingChannel.m_channel,
                            (float) kPingTime); // do the ping
                }
                u = u.m_nextSensor;
                Timer.delay(.1); // wait for ping to return
            }
        }

    }

}
